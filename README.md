# BlaBlaBla – Rider-Driver System
<p align="center">
  <img width="620" alt="Screenshot 2025-06-30 at 12 50 05"
       src="https://github.com/user-attachments/assets/3e6f06cc-c2cc-45e5-9198-49421bbda599" />
  <img width="960" alt="Screenshot 2025-06-30 at 12 50 21"
       src="https://github.com/user-attachments/assets/187a29f1-bb72-454e-b80d-267f4d466e14" />
</p>

Наразі в системі є два типи комунікації: синхронна (REST API) та асинхронна (RabbitMQ). Інші типи синхронної комунікації не розглядались, водночас вважаю, що REST є найоптимальнішим варіантом у зв'язку з простотою, зрозумілістю тощо (універсальний варіант).

## Кейс 1: Web-клієнт → API Gateway (Kubernetes Ingress)
**Sync**  
| Технологія  | Плюси                                                                                                                                         | Мінуси                                                                                                                                           |
|-------------|------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------|
| **REST**    | • Всі браузери й HTTP-клієнти “з коробки” підтримують JSON/HTTP<br>• CDN/Ingress можуть кешувати GET-відповіді<br>• OpenAPI дозволяє швидко документувати<br>• Спека зручна для AI-агентів.  | • Фіксовані схеми відповіді – over-(n+1)/under-fetching, якщо без Data Loader<br>• Зі збільшенням ендпоінтів важче підтримувати<br>• JSON значно більший за бінарні формати  |
| **GraphQL** | • Один endpoint → не треба додавати нові URL під кожен ресурс<br>• Клієнт витягує тільки потрібні поля<br>• Вбудована інспекція схеми для UI-інструментів<br> | • POST-запити складніше кешувати CDN/Ingress<br>• Потрібен шар резолверів → додаткова логіка й latency<br>• Необхідно захищати від “важких” запитів<br>• JSON значно більший за бінарні формати |
| **gRPC-Web**| • Бінарний Protobuf → менше трафіку<br>• HTTP/2 мультиплекс → швидше встановлення і менше затримки<br>• Авто-генерація клієнтського коду• Over-fetching/n+1, якщо без Data Loader<br>            | • Потрібен grpc-web proxy (Envoy, nginx) для браузера<br>• Відсутнє стандартне HTTP-кешування<br>• Дебаг через grpcurl/спеціальні інструменти          |

**Вибір:** REST (проста edge-точка, CDN, мінімум змін, зрозумілість та оптимальність (наприклад, із GraphQL можна намудрити ще більше оверхеду, ніж бенефітів))  

**CQRS/ES:** не потрібні

---

## Кейс 2: API Gateway → Main Service  
**Sync**  
| Технологія  | Плюси                                                                                                                                           | Мінуси                                                                                                                                             |
|-------------|--------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------|
| **REST**    | • Нативне проксування в Kubernetes Ingress і API Gateway<br>• OpenAPI/Swagger → генерація клієнтів<br>• GET-кешування в Ingress                   | • При зміні схеми доводиться версіонувати URI або складати нові заголовки<br>• Over-/under-fetching при складних об’єктах                             |
| **GraphQL** | • Один endpoint → Gateway не треба переналаштовувати під нові ресурси<br>                   | • Потребує додаткового GraphQL-сервера<br>• Кешування POST-запитів складне<br>• Потрібен контроль глибин і складності запитів               |
| **gRPC**    | • Протоколи Protobuf дають суворий контракт і менше помилок<br>• HTTP/2 із мультиплексом → нижча латентність<br>• Підтримка стрімінгу результатів | • Потрібен проксі для HTTP/2+gRPC (Envoy/nginx)<br>• Немає CDN-кешування<br>• Управління TLS і HTTP/2 ускладнює інфраструктуру                         |

**Вибір:** REST (Ingress + Main Service вже на HTTP/JSON). 
** Для умовного BlaBlaBla cервісу вже є predefined ендпоінти, які зручно менеджити саме REST API, хоча для випадків із, наприклад, decline/accept пасажира проситься gRPC is remote procedure call, але це можна реалізувати за допомогою PATCH і передавати стан статусу, хоч і PATCH не ідемпотентний

**CQRS/ES:** не потрібні

---

## Кейс 3: Service-to-Service (Main → User/Order/Ride/Auth (хоча Auth не реалізовували))  
**Sync**  
| Технологія  | Плюси                                                                                                                                              | Мінуси                                                                                                                        |
|-------------|-----------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------|
| **REST**    | • Швидкий старт – HTTP/1.1 та JSON прості в налаштуванні<br>• Звичні інструменти моніторингу та логування                                           | • JSON-overhead при високому трафіку<br>• Відсутність контрактного типу без схеми<br>• Немає підтримик стримінгу без додаткових інструментів                         |
| **GraphQL** | • Можна одним запитом отримати відразу кілька сутностей з різних сервісів                                                                         | • Не характерно для s2s, додає latency у шар резолверів<br>• Кешування не критичне, але вимагає DataLoader для батчінгу         |
| **gRPC**    | • Протоколи Protobuf → строга типізація, мінімум overhead<br>• HTTP/2 з мультиплексом → низька латентність, підтримка deadline і cancellation<br>• Стрімінг | • Налаштування HTTP/2, TLS, проксі ускладнює інфраструктуру<br>• Дебаг вимагає спеціальних утиліт                              |

**Вибір:** ми обрали REST, хоча наразі я думаю, що gRPC також був би гарним варіантом, за умови гарного його проєктування (висока частота викликів, contract-first, стримінг)  

**CQRS:** не застосувується 

**Event Sourcing:** Order/Ride для аудиту/відтворення подій (можна поставити івенти на події, що змінюють статус (order.created, etc.))

---

## Кейс 4–5: Main → Notification / Main -> Payment (Anti-Corruption Layer)
**Async**  
| Технологія           | Плюси                                                                                                       | Мінуси                 |
|----------------------|-------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------|
| **REST**             | —                                                                                                                             | Не підійде — потрібна асинхронна комунікація |
| **GraphQL**          | —                                                                                                                             | Не підійде — потрібна асинхронна комунікація |
| **gRPC**             | —                                                                                                                             | Не підійде — потрібна асинхронна комунікація |
| **Message Broker**   | • Гарантована доставка з retry і DLQ<br> • Decoupling Main Service від Open Host services<br> • Ідеально підходить для Anti-Corruption Layer | • Додаткова інфраструктура<br>• Необхідний моніторинг черг |


**Вибір:** Message Broker (P2P message unidirectional gueue для Main -> Notification, bidirectional реалізована через дві P2P message queues Main -> Payment, Payment -> Main для відповіді). DLQ exchange + default exchange для інших черг

**CQRS:** не застосовується на рівні message брокерів

**Event Sourcing:** Payment для аудиту/відтворення подій (можна поставити івенти на події, що змінюють статус (payment.processed, etc.))

Для наступних кейсів ми просто використовуємо апішки, представлені \*провайдерами\*, які під капотом реалізовані на REST API, тому й по суті саме REST тут і підходить через це.
## Кейс 5: Notification Service → SendGrid  
**Sync (REST) + Webhook callback**  
| Технологія   | Плюси                                                                                          | Мінуси                                                    |
|--------------|------------------------------------------------------------------------------------------------|-----------------------------------------------------------|
| **REST**     | • Багаті SDK і приклади коду<br>• Швидкий HTTP-відгук (2xx/4xx)<br>• Проста серіалізація JSON     | • Rate limits провайдера<br>• Немає вбудованого retry/DLQ  |
| **GraphQL**  | — (не застосовується)                                                                           | —                                                         |
| **gRPC**     | — (не застосовується)                                                                           | —                                                         |
| **MQ**       | — (не застосовується для зовнішніх sync API)                                                    | —                                                         |

**Вибір:** REST

**CQRS/ES:** не потрібні

---

## Кейс 6: Payment Service → Stripe  
**Sync (REST) + Webhook callback**  
| Технологія   | Плюси                                                                                          | Мінуси                                                    |
|--------------|------------------------------------------------------------------------------------------------|-----------------------------------------------------------|
| **REST**     | • Idempotency-ключі для безпечного повтору<br>• Багаті SDK і документація (OpenAPI)             | • Rate limits провайдера<br>• Немає вбудованого retry/DLQ     |
| **GraphQL**  | — (не застосовується)                                                                           | —                                                         |
| **gRPC**     | — (не застосовується)                                                                           | —                                                         |
| **MQ**       | — (не застосовується для зовнішніх sync API)                                                    | —                                                         |
| **Webhook**  | • Асинхронні події про успіх/провал платежу<br>• Не треба опитувати API                        | • Потрібна валідація підпису<br>• Додатковий HTTP-ендпоінт  |

**Вибір:** REST + Webhook  

**CQRS/ES:** не потрібні

**CQRS** можна було б застосувати, якби був Metrics/Analytics service, який би приймав мало записів, але багато зчитувань.
**Event Sourcing** хоча ми не використовували ES, але зрозуміла, що було б добре зберігати essential доменні події.









